# dummyBoard

어떤 프로젝트인가? : 간단한 웹 게시판

왜 만들었나? : 실질적인 개발-배포 과정을 익히기 위해, 그리고 Spring/React에 익숙해지기 위해

---

## 기능
- **회원가입/로그인**
- **게시글/댓글 작성**
- **게시글 조회**
- **게시글 검색**
- **게시글/댓글 삭제**

---

## 기술 스택
- **백엔드** : Java
 - Spring
 - MySQL

- **프론트** : Javascript
 - React
 - Axios(API 호출)
 - Vite(개발 서버)

- **배포**
 - Docker(예정)

---

## DB 스키마
 - users 테이블
  - id char(36) : Primary Key. UUID() 내장 함수로 생성
  - username varchar(50) : 로그인 시 사용되는 유저명
  - password char(60) : bcrypt 로 단방향 암호화된 문자열
  - email varchar(254) : RFC 5321 기준 전체 주소는 최대 254자 제한. 메일 주소 전체를 하나의 컬럼으로 저장하는 일반적 기준을 따름
  - created_at datetime : 가입일시


# 개발 과정

## 1. 구현해야 할 기능을 정하기
 - 프론트엔드와 백엔드를 완전히 분리한 만큼, 각자 어떤 기능을 구현할 것인지를 설계 단계에서 명확하게 하자.

백엔드
 1. 회원가입
  1.1. 유저명/이메일 중복체크 요청
   - DB에 쿼리한 다음 유저명/이메일이 사용 가능한지 여부를 리턴
  1.2. 회원가입 요청
   - 중복된 정보가 없고, 형식에 맞는 정보를 입력했다면 DB에 신규 회원 정보를 저장. 패스워드는 Bcrypt를 사용해 단방향 암호화해 저장
   - 중복된 정보 등으로 회원가입에 실패했다면 실패 사유를 리턴, 성공했다면 성공 여부를 리턴
2. 로그인
 2.1. 로그인 요청
  - DB에 쿼리해서 회원 정보가 유효한지 검증
 2.2. 토큰 발급
  - JWT 토큰 사용, 액세스 토큰과 리프레시 토큰을 분리
  - TTL 설정과 빠른 액세스를 위해 리프레시 토큰은 Redis에 저장
3. 게시글 작성
4. 게시글 검색
5. 게시글 조회

프론트엔드
 1. 로그인/회원가입
  - 로그인 창은 팝업 형식으로, 현재 페이지에서 이탈하지 않고 팝업 형식으로 표시
  - 로그인 버튼을 누르거나, 로그인이 필요한 서비스에 접근하려고 할 때 팝업됨
  - 회원가입도 로그인과 똑같지만, 로그인 창 아래 회원가입 링크를 클릭하면 팝업됨.
  - 로그인 된 상태라면 로그인 창은 띄워지지 않음

# 로그인
 1. 토큰 방식의 로그인
  - 세션 방식의 로그인은 높은 보안성을 가지므로 은행이나 기업 내부망에 사용
  - 하지만 서버에 부담이 감
  - dumbo는 간단한 웹 게시판 프로젝트이므로, 요구되는 보안성이 상대적으로 낮다고 판단
  - 따라서 서버에 부담이 덜한 토큰 발급 방식을 선택

2. 이중 토큰 방식
 - 단일 토큰 방식(액세스 토큰만 사용)은 구현이 간단하고 서버에 부담이 덜함
 - 하지만 유효 기간 설정에 애매한 면이 있음
 - 유효 기간이 너무 짧으면 유저는 로그인을 자주 해야 하고, 너무 길면 토큰을 탈취당했을 때의 위험이 커짐
 - 따라서 액세스 토큰을 발급받을 수 있는 권한인 리프레시 토큰을 도입
 - 리프레시 토큰은 액세스 토큰이 만료되었을 때만 사용되므로, 조금 더 안전하게 보관해도 번거롭지 않음(HttpsOnly 설정 등)
 - 리프레시 토큰의 TTL 설정, 접근 시 오버헤드를 최소화하기 위해 Redis에 저장
 - 로그아웃 시 리프레시 토큰을 서버에서 파기(또는 리프레시 토큰의 TTL 만료 시), 클라이언트에서는 쓸모가 없어진 리프레시 토큰 파기(UX상 파기하는 것이 좋다고 생각)
 - 리프레시 토큰이 없더라도 액세스 토큰만 있으면 서비스에 접근 가능하기에, 액세스 토큰이 탈취되었을 때의 위험은 여전히 존재
 - 이중 토큰 방식에서 액세스 토큰의 유효기간을 짧게 설정하면 UX에는 큰 지장이 없지만 토큰이 탈취되었을 때의 위험은 낮아짐

 3. 리프레쉬 토큰 로테이션
  - 리프레쉬 토큰이 탈취되었을 경우의 문제는 여전히 남아있음
  - 사용자가 리프레쉬 토큰을 사용해서 액세스 토큰을 발급받을 때, 리프레쉬 토큰 역시 재발급하는 방식을 채택

4. 핸들러 인터셉터
 - 웹 게시판의 글 조회나 탐색 등은 로그인 없이도 가능한 것이 일반적(폐쇄적인 서비스가 아니라면)
 - 해당 프로젝트도 위 방식을 지향
 - 하지만 게시글/댓글의 작성/수정/삭제 등의 요청은 로그인이 필요함
 - 로그인 되지 않은 사용자가 글의 작성/수정/삭제 등의 요청을 보내는 경우, 프론트엔드에서 1차적으로 로그인 창을 띄워 로그인 할 것을 유도(UX상)
 - 2차적으로 백엔드에서는 로그인되지 않은 유저의 글의 작성/수정/삭제 요청을 거부
 - 3차적으로 로그인이 되어 있더라도, 액세스 토큰에 저장된 해당 유저 정보와 해당 글귀의 작성자가 일치하지 않는다면 요청을 거부

 # 회원가입
 1. 유저 정보 중 고유값
  - username, email은 유저가 사용하기를 희망하는 값을 직접 입력함
  - UX를 위해 중복 체크 기능을 구현
  - 하지만 중복 체크 요청과 회원가입 요청은 다른 요청이며, 분리되어 있음
  - A유저가 'a' 유저네임을 중복체크(사용가능) -> B유저가 'a' 유저네임으로 회원가입 요청(성공) -> A유저가 회원가입(실패) 같은 상황 발생 가능성 있음
  - 중복체크를 한 고유값이 사용 가능하다면, 해당 고유값에 락을 걸어주는 방법을 생각함
  - 하지만 구현이 지나치게 복잡해지며, 악용당할 가능성을 내포하고 있음(사용 가능한 모든 값에 락을 거는 문제)
  - 따라서 중복체크 기능은 UX상 구현하되, 회원가입 요청 시 중복값이 발생한다면 유저에게 고지하는 방향으로 수정
  - 회원가입 요청 : 우선 DB에 유저 정보 등록을 시도하고, 실패(예외 발생)한다면 추가적인 쿼리를 거쳐 중복된 정보가 무엇인지를 고지
  - 선택 방식의 트레이드 오프 : 회원가입 실패 시 추가적인 쿼리 발생

2. 중복 체크 API의 악용 가능성
 - 1에서 언급했듯 중복 체크 API는 유저 정보를 부분적으로 탈취하는 데 사용될 수 있음
 - Redis를 이용, 해당 API 요청을 보낸 IP를 저장하고, TTL을 설정하는 방식으로 대응.
 - Redis에 저장되어 있는 IP에서 또 요청이 올 경우, TTL을 더 증가시키는 방식도 적용.

 # 게시글
1. 비로그인 상태에서의 글/댓글 작성
 - 비로그인 상태에서 작성된 글/댓글의 경우 아이피를 수집하고 저장 : 글/댓글 작성시 경고문 표시(수정/삭제 불가, 아이피가 서버에 저장됨)
 - 지속적인 경고문 표시는 번거로움을 유발 -> 로그인 유도하기 위한 의도된 UX 저하
 - 비로그인 상태에서 작성된 글의 경우 IP의 앞 두자리(*.*)를 닉네임 대신에 표시
 - 기존 일부 커뮤니티 사이트는 비로그인으로 글을 작성할 시 비밀번호를 같이 지정하고, 해당 글/댓글에 대한 삭제/수정 기능을 지원
 - 하지만 본 프로젝트는 비로그인 상태에서 작성된 글/댓글은 삭제/수정을 지원하지 않음 : 익명성이 보장될수록 발언에 책임을 부과하는 방법

2. 인기 게시글 캐싱


# DB DAO 설계
1. 사용하는 DB나 커넥션을 생성하는 방식이 추후에 변경될 가능성을 고려
 - 기존에는 상속관계와 인터페이스를 활용하려 함
 - Spring의 application.properties를 통해 Datasource를 가져오는 방법이 있음을 알게 됨
 - 많은 코드의 작성보다, 이미 제공되는 기능을 사용하기로 결정
 - application.properties에 작성되어 있는 정보를 바탕으로, Datasource를 리턴하는 방식으로 수정
 - DBConnectionMaker 클래스는 Datasource를 DI받고, Datasource.getConnection() 으로 DB커넥션 생성
 - DBConnectionMaker를 상속받아 Override 하는 방식으로 Connection을 얻어올 수 있는 방법의 확장성을 노림

2. DB에 어떻게 쿼리를 하고 가져올 것인지에 대한 관심 구분
 - 우선은 익숙한 방식으로 구현
 - SQL을 직접 작성, 커넥션 직접 받아오기, PreparedStatement로 Value 넣기, ResultSet으로 데이터 가져와서 Entity의 Setter로 엔티티 생성 후 리턴
 - 하지만 추후 프로젝트가 커지게 될 경우 JPA나 MyBatis 등의 확장을 사용할 것을 고려해야 함
 - interface를 중간에 두는 방식을 사용
 - DAO는 어떠한 방식으로 DB에 쿼리가 일어나는지는 모르지만, DB에서 조회한 엔티티를 사용 가능
 - 추후 해당 인터페이스에 DI될 객체를 Configuration(Factory)에서 설정만 바꾸면 됨.
 - 기능과 책임의 분리는 확장성/재활용성을 늘려 주지만, 코드가 지나치게 복잡해진다는 트레이드 오프가 있음
 - 그렇기 때문에 우선은 익숙한 방식으로 DAO에서 쿼리 기능을 구현해 놓자.

3. DAO
 - 인터페이스 형식으로 구현하고, DAO를 이용하는 객체에는 주입
 - 어떤 구현체를 주입하나? -> application.properties에서 설정할 수 있도록 구현하는 것이 확장성과 유연성 면에서 좋다고 판단

# Redis(Lettuce 사용)
 1. 커넥션 풀
  - Lettuce는 싱글 커넥션 공유 방식으로 충분한 고성능을 제공
  - StatefulREdisConnection 인스턴스를 여러 쓰레드에서 동시에 공유할 수 있도록 설계되어 있음
  - 하지만 싱글톤으로 관리되어야 함
  - Spring의 Bean으로 Redis 기능을 제공하는 객체를 관리


# 핵심 로직
1. 다중 로그인 제한
 - 로그인 요청이 들어오고, 검증이 완료되었을 경우
 - 리프레시 토큰을 새로 발급하고, 기존에 리프레시 토큰이 있을 경우 만료시킴
 - 다른 기기에서 로그인했던 유저는 액세스 토큰이 만료될 때까지만 로그인 유효

2. 로그인 확인/유지
 - 메인 페이지 접속 시 액세스 토큰(Redux 전역 상태로 관리)이 있는지 확인
 - 액세스 토큰이 있다면 로그인 된 것으로 판단
 - 액세스 토큰이 없다면 액세스 토큰 발급 요청(withCredential true)
 - 서버로부터 리프레시 토큰(을 담은 쿠키)가 없거나, 만료되었다는 응답 : 로그인 되지 않은 것으로 판단
 - 서버로부터 리프레시 토큰과 액세스 토큰을 담은 쿠키가 전송될 경우 : 로그인 유지

3. 로그아웃
 - 클라이언트는 액세스 토큰을 삭제하고, 서버로 리프레시 토큰을 담은 요청을 보냄
 - 서버는 요청에 리프레시 토큰이 있는지 판단
 - 요청에 리프레시 토큰이 있다면 -> 그리고 리프레시 토큰이 유효하다면 -> Redis에서 리프레시 토큰 삭제
 - 서버는 Set-Cookie 응답 헤더로 클라이언트의 리프레시 토큰 삭제 지시(리프레시 토큰이 유효하지 않거나 없더라도)
 - 클라이언트는 응답 헤더를 보고 리프레시 토큰을 삭제(리프레시 토큰(쿠키)의 존재/유효 여부는 브라우저가 알 수 없음)


